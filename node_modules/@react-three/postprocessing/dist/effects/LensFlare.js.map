{"version":3,"file":"LensFlare.js","sources":["../../src/effects/LensFlare.tsx"],"sourcesContent":["// Created by Anderson Mancini 2023\n// From https://github.com/ektogamat/R3F-Ultimate-Lens-Flare\n\nimport * as THREE from 'three'\nimport { useEffect, useState, useContext, useRef } from 'react'\nimport { useFrame, useThree } from '@react-three/fiber'\nimport { BlendFunction, Effect } from 'postprocessing'\nimport { easing } from 'maath'\n\nimport { EffectComposerContext } from '../EffectComposer'\nimport { wrapEffect } from '../util'\n\nconst LensFlareShader = {\n  fragmentShader: /* glsl */ `\n    uniform float time;\n    uniform vec2 lensPosition;\n    uniform vec2 screenRes;\n    uniform vec3 colorGain;\n    uniform float starPoints;\n    uniform float glareSize;\n    uniform float flareSize;\n    uniform float flareSpeed;\n    uniform float flareShape;\n    uniform float haloScale;\n    uniform float opacity;\n    uniform bool animated;\n    uniform bool anamorphic;\n    uniform bool enabled;\n    uniform bool secondaryGhosts;\n    uniform bool starBurst;\n    uniform float ghostScale;\n    uniform bool aditionalStreaks;\n    uniform sampler2D lensDirtTexture;\n    vec2 vTexCoord;\n    \n    float rand(float n){return fract(sin(n) * 43758.5453123);}\n\n    float noise(float p){\n      float fl = floor(p);\n      float fc = fract(p);\n      return mix(rand(fl),rand(fl + 1.0), fc);\n    }\n\n    vec3 hsv2rgb(vec3 c)\n    {\n      vec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n      vec3 p = abs(fract(c.xxx + k.xyz) * 6.0 - k.www);\n      return c.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), c.y);\n    }\n\n    float saturate(float x)\n    {\n      return clamp(x, 0.,1.);\n    }\n\n    vec2 rotateUV(vec2 uv, float rotation)\n    {\n      return vec2(\n          cos(rotation) * uv.x + sin(rotation) * uv.y,\n          cos(rotation) * uv.y - sin(rotation) * uv.x\n      );\n    }\n\n    // Based on https://www.shadertoy.com/view/XtKfRV\n    vec3 drawflare(vec2 p, float intensity, float rnd, float speed, int id)\n    {\n      float flarehueoffset = (1. / 32.) * float(id) * 0.1;\n      float lingrad = distance(vec2(0.), p);\n      float expgrad = 1. / exp(lingrad * (fract(rnd) * 0.66 + 0.33));\n      vec3 colgrad = hsv2rgb(vec3( fract( (expgrad * 8.) + speed * flareSpeed + flarehueoffset), pow(1.-abs(expgrad*2.-1.), 0.45), 20.0 * expgrad * intensity)); //rainbow spectrum effect\n\n      float internalStarPoints;\n\n      if(anamorphic){\n        internalStarPoints = 1.0;\n      } else{\n        internalStarPoints = starPoints;\n      }\n      \n      float blades = length(p * flareShape * sin(internalStarPoints * atan(p.x, p.y)));\n      \n      float comp = pow(1.-saturate(blades), ( anamorphic ? 100. : 12.));\n      comp += saturate(expgrad-0.9) * 3.;\n      comp = pow(comp * expgrad, 8. + (1.-intensity) * 5.);\n      \n      if(flareSpeed > 0.0){\n        return vec3(comp) * colgrad;\n      } else{\n        return vec3(comp) * flareSize * 15.;\n      }\n    }\n\n    float dist(vec3 a, vec3 b) { return abs(a.x - b.x) + abs(a.y - b.y) + abs(a.z - b.z); }\n\n    vec3 saturate(vec3 x)\n    {\n      return clamp(x, vec3(0.0), vec3(1.0));\n    }\n\n    // Based on https://www.shadertoy.com/view/XtKfRV\n    float glare(vec2 uv, vec2 pos, float size)\n    {\n      vec2 main;\n\n      if(animated){\n        main = rotateUV(uv-pos, time * 0.1);      \n      } else{\n        main = uv-pos;     \n      }\n      \n      float ang = atan(main.y, main.x) * (anamorphic ? 1.0 : starPoints);\n      float dist = length(main); \n      dist = pow(dist, .9);\n      \n      float f0 = 1.0/(length(uv-pos)*(1.0/size*16.0)+.2);\n\n      return f0+f0*(sin((ang))*.2 +.3);\n    }\n\n    float sdHex(vec2 p){\n      p = abs(p);\n      vec2 q = vec2(p.x*2.0*0.5773503, p.y + p.x*0.5773503);\n      return dot(step(q.xy,q.yx), 1.0-q.yx);\n    }\n\n    //Based on https://www.shadertoy.com/view/dllSRX\n    float fpow(float x, float k){\n      return x > k ? pow((x-k)/(1.0-k),2.0) : 0.0;\n    }\n\n    vec3 renderhex(vec2 uv, vec2 p, float s, vec3 col){\n      uv -= p;\n      if (abs(uv.x) < 0.2*s && abs(uv.y) < 0.2*s){\n          return mix(vec3(0),mix(vec3(0),col,0.1 + fpow(length(uv/s),0.1)*10.0),smoothstep(0.0,0.1,sdHex(uv*20.0/s)));\n      }\n      return vec3(0);\n    }\n\n    // Based on https://www.shadertoy.com/view/4sX3Rs\n    vec3 LensFlare(vec2 uv, vec2 pos)\n    {\n      vec2 main = uv-pos;\n      vec2 uvd = uv*(length(uv));\n      \n      float ang = atan(main.x,main.y);\n      \n      float f0 = .3/(length(uv-pos)*16.0+1.0);\n      \n      f0 = f0*(sin(noise(sin(ang*3.9-(animated ? time : 0.0) * 0.3) * starPoints))*.2 );\n      \n      float f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\n\n      float f2 = max(.9/(10.0+32.0*pow(length(uvd+0.99*pos),2.0)),.0)*0.35;\n      float f22 = max(.9/(11.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*0.23;\n      float f23 = max(.9/(12.0+32.0*pow(length(uvd+0.95*pos),2.0)),.0)*0.6;\n      \n      vec2 uvx = mix(uv,uvd, 0.1);\n      \n      float f4 = max(0.01-pow(length(uvx+0.4*pos),2.9),.0)*4.02;\n      float f42 = max(0.0-pow(length(uvx+0.45*pos),2.9),.0)*4.1;\n      float f43 = max(0.01-pow(length(uvx+0.5*pos),2.9),.0)*4.6;\n      \n      uvx = mix(uv,uvd,-.4);\n      \n      float f5 = max(0.01-pow(length(uvx+0.1*pos),5.5),.0)*2.0;\n      float f52 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\n      float f53 = max(0.01-pow(length(uvx+0.1*pos),5.5),.0)*2.0;\n      \n      uvx = mix(uv,uvd, 2.1);\n      \n      float f6 = max(0.01-pow(length(uvx-0.3*pos),1.61),.0)*3.159;\n      float f62 = max(0.01-pow(length(uvx-0.325*pos),1.614),.0)*3.14;\n      float f63 = max(0.01-pow(length(uvx-0.389*pos),1.623),.0)*3.12;\n      \n      vec3 c = vec3(glare(uv,pos, glareSize));\n\n      vec2 prot;\n\n      if(animated){\n        prot = rotateUV(uv - pos, (time * 0.1));  \n      } else if(anamorphic){\n        prot = rotateUV(uv - pos, 1.570796);     \n      } else {\n        prot = uv - pos;\n      }\n\n      c += drawflare(prot, (anamorphic ? flareSize * 10. : flareSize), 0.1, time, 1);\n      \n      c.r+=f1+f2+f4+f5+f6; c.g+=f1+f22+f42+f52+f62; c.b+=f1+f23+f43+f53+f63;\n      c = c*1.3 * vec3(length(uvd)+.09);\n      c+=vec3(f0);\n      \n      return c;\n    }\n\n    vec3 cc(vec3 color, float factor,float factor2)\n    {\n      float w = color.x+color.y+color.z;\n      return mix(color,vec3(w)*factor,w*factor2);\n    }    \n\n    float rnd(vec2 p)\n    {\n      float f = fract(sin(dot(p, vec2(12.1234, 72.8392) )*45123.2));\n      return f;   \n    }\n\n    float rnd(float w)\n    {\n      float f = fract(sin(w)*1000.);\n      return f;   \n    }\n\n    float regShape(vec2 p, int N)\n    {\n      float f;\n      \n      float a=atan(p.x,p.y)+.2;\n      float b=6.28319/float(N);\n      f=smoothstep(.5,.51, cos(floor(.5+a/b)*b-a)*length(p.xy)* 2.0  -ghostScale);\n          \n      return f;\n    }\n\n    // Based on https://www.shadertoy.com/view/Xlc3D2\n    vec3 circle(vec2 p, float size, float decay, vec3 color, vec3 color2, float dist, vec2 position)\n    {\n      float l = length(p + position*(dist*2.))+size/2.;\n      float l2 = length(p + position*(dist*4.))+size/3.;\n      \n      float c = max(0.01-pow(length(p + position*dist), size*ghostScale), 0.0)*10.;\n      float c1 = max(0.001-pow(l-0.3, 1./40.)+sin(l*20.), 0.0)*3.;\n      float c2 =  max(0.09/pow(length(p-position*dist/.5)*1., .95), 0.0)/20.;\n      float s = max(0.02-pow(regShape(p*5. + position*dist*5. + decay, 6) , 1.), 0.0)*1.5;\n      \n      color = cos(vec3(0.44, .24, .2)*16. + dist/8.)*0.5+.5;\n      vec3 f = c*color;\n      f += c1*color;\n      f += c2*color;  \n      f +=  s*color;\n      return f;\n    }\n\n    vec4 getLensColor(float x){\n      return vec4(vec3(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(vec3(0., 0., 0.),\n        vec3(0., 0., 0.), smoothstep(0.0, 0.063, x)),\n        vec3(0., 0., 0.), smoothstep(0.063, 0.125, x)),\n        vec3(0.0, 0., 0.), smoothstep(0.125, 0.188, x)),\n        vec3(0.188, 0.131, 0.116), smoothstep(0.188, 0.227, x)),\n        vec3(0.31, 0.204, 0.537), smoothstep(0.227, 0.251, x)),\n        vec3(0.192, 0.106, 0.286), smoothstep(0.251, 0.314, x)),\n        vec3(0.102, 0.008, 0.341), smoothstep(0.314, 0.392, x)),\n        vec3(0.086, 0.0, 0.141), smoothstep(0.392, 0.502, x)),\n        vec3(1.0, 0.31, 0.0), smoothstep(0.502, 0.604, x)),\n        vec3(.1, 0.1, 0.1), smoothstep(0.604, 0.643, x)),\n        vec3(1.0, 0.929, 0.0), smoothstep(0.643, 0.761, x)),\n        vec3(1.0, 0.086, 0.424), smoothstep(0.761, 0.847, x)),\n        vec3(1.0, 0.49, 0.0), smoothstep(0.847, 0.89, x)),\n        vec3(0.945, 0.275, 0.475), smoothstep(0.89, 0.941, x)),\n        vec3(0.251, 0.275, 0.796), smoothstep(0.941, 1.0, x))),\n      1.0);\n    }\n\n    float dirtNoise(vec2 p){\n      vec2 f = fract(p);\n      f = (f * f) * (3.0 - (2.0 * f));    \n      float n = dot(floor(p), vec2(1.0, 157.0));\n      vec4 a = fract(sin(vec4(n + 0.0, n + 1.0, n + 157.0, n + 158.0)) * 43758.5453123);\n      return mix(mix(a.x, a.y, f.x), mix(a.z, a.w, f.x), f.y);\n    } \n\n    float fbm(vec2 p){\n      const mat2 m = mat2(0.80, -0.60, 0.60, 0.80);\n      float f = 0.0;\n      f += 0.5000*dirtNoise(p); p = m*p*2.02;\n      f += 0.2500*dirtNoise(p); p = m*p*2.03;\n      f += 0.1250*dirtNoise(p); p = m*p*2.01;\n      f += 0.0625*dirtNoise(p);\n      return f/0.9375;\n    }\n\n    vec4 getLensStar(vec2 p){\n      vec2 pp = (p - vec2(0.5)) * 2.0;\n      float a = atan(pp.y, pp.x);\n      vec4 cp = vec4(sin(a * 1.0), length(pp), sin(a * 13.0), sin(a * 53.0));\n      float d = sin(clamp(pow(length(vec2(0.5) - p) * 0.5 + haloScale /2., 5.0), 0.0, 1.0) * 3.14159);\n      vec3 c = vec3(d) * vec3(fbm(cp.xy * 16.0) * fbm(cp.zw * 9.0) * max(max(max(max(0.5, sin(a * 1.0)), sin(a * 3.0) * 0.8), sin(a * 7.0) * 0.8), sin(a * 9.0) * 10.6));\n      c *= vec3(mix(2.0, (sin(length(pp.xy) * 256.0) * 0.5) + 0.5, sin((clamp((length(pp.xy) - 0.875) / 0.1, 0.0, 1.0) + 0.0) * 2.0 * 3.14159) * 1.5) + 0.5) * 0.3275;\n      return vec4(vec3(c * 1.0), d);\t\n    }\n\n    vec4 getLensDirt(vec2 p){\n      p.xy += vec2(fbm(p.yx * 3.0), fbm(p.yx * 2.0)) * 0.0825;\n      vec3 o = vec3(mix(0.125, 0.25, max(max(smoothstep(0.1, 0.0, length(p - vec2(0.25))),\n                                            smoothstep(0.4, 0.0, length(p - vec2(0.75)))),\n                                            smoothstep(0.8, 0.0, length(p - vec2(0.875, 0.125))))));\n      o += vec3(max(fbm(p * 1.0) - 0.5, 0.0)) * 0.5;\n      o += vec3(max(fbm(p * 2.0) - 0.5, 0.0)) * 0.5;\n      o += vec3(max(fbm(p * 4.0) - 0.5, 0.0)) * 0.25;\n      o += vec3(max(fbm(p * 8.0) - 0.75, 0.0)) * 1.0;\n      o += vec3(max(fbm(p * 16.0) - 0.75, 0.0)) * 0.75;\n      o += vec3(max(fbm(p * 64.0) - 0.75, 0.0)) * 0.5;\n      return vec4(clamp(o, vec3(0.15), vec3(1.0)), 1.0);\t\n    }\n\n    vec4 textureLimited(sampler2D tex, vec2 texCoord){\n      if(((texCoord.x < 0.) || (texCoord.y < 0.)) || ((texCoord.x > 1.) || (texCoord.y > 1.))){\n        return vec4(0.0);\n      }else{\n        return texture(tex, texCoord); \n      }\n    }\n\n    vec4 textureDistorted(sampler2D tex, vec2 texCoord, vec2 direction, vec3 distortion) {\n      return vec4(textureLimited(tex, (texCoord + (direction * distortion.r))).r,\n                  textureLimited(tex, (texCoord + (direction * distortion.g))).g,\n                  textureLimited(tex, (texCoord + (direction * distortion.b))).b,\n                  1.0);\n    }\n\n    // Based on https://www.shadertoy.com/view/4sK3W3\n    vec4 getStartBurst(){\n      vec2 aspectTexCoord = vec2(1.0) - (((vTexCoord - vec2(0.5)) * vec2(1.0)) + vec2(0.5)); \n      vec2 texCoord = vec2(1.0) - vTexCoord; \n      vec2 ghostVec = (vec2(0.5) - texCoord) * 0.3 - lensPosition;\n      vec2 ghostVecAspectNormalized = normalize(ghostVec * vec2(1.0)) * vec2(1.0);\n      vec2 haloVec = normalize(ghostVec) * 0.6;\n      vec2 haloVecAspectNormalized = ghostVecAspectNormalized * 0.6;\n      vec2 texelSize = vec2(1.0) / vec2(screenRes.xy);\n      vec3 distortion = vec3(-(texelSize.x * 1.5), 0.2, texelSize.x * 1.5);\n      vec4 c = vec4(0.0);\n      for (int i = 0; i < 8; i++) {\n        vec2 offset = texCoord + (ghostVec * float(i));\n        c += textureDistorted(lensDirtTexture, offset, ghostVecAspectNormalized, distortion) * pow(max(0.0, 1.0 - (length(vec2(0.5) - offset) / length(vec2(0.5)))), 10.0);\n      }                       \n      vec2 haloOffset = texCoord + haloVecAspectNormalized; \n      return (c * getLensColor((length(vec2(0.5) - aspectTexCoord) / length(vec2(haloScale))))) + \n            (textureDistorted(lensDirtTexture, haloOffset, ghostVecAspectNormalized, distortion) * pow(max(0.0, 1.0 - (length(vec2(0.5) - haloOffset) / length(vec2(0.5)))), 10.0));\n    } \n\n    void mainImage(vec4 inputColor, vec2 uv, out vec4 outputColor)\n    {\n      vec2 myUV = uv -0.5;\n      myUV.y *= screenRes.y/screenRes.x;\n      vec2 finalLensPosition = lensPosition * 0.5;\n      finalLensPosition.y *= screenRes.y/screenRes.x;\n      \n      //First Lens flare pass\n      vec3 finalColor = LensFlare(myUV, finalLensPosition) * 20.0 * colorGain / 256.;\n\n      //Aditional streaks\n      if(aditionalStreaks){\n        vec3 circColor = vec3(0.9, 0.2, 0.1);\n        vec3 circColor2 = vec3(0.3, 0.1, 0.9);\n\n        for(float i=0.;i<10.;i++){\n          finalColor += circle(myUV, pow(rnd(i*2000.)*2.8, .1)+1.41, 0.0, circColor+i , circColor2+i, rnd(i*20.)*3.+0.2-.5, lensPosition);\n        }\n      }\n\n      //Alternative ghosts\n      if(secondaryGhosts){\n        vec3 altGhosts = vec3(0);\n        altGhosts += renderhex(myUV, -lensPosition*0.25, ghostScale * 1.4, vec3(0.25,0.35,0));\n        altGhosts += renderhex(myUV, lensPosition*0.25, ghostScale * 0.5, vec3(1,0.5,0.5));\n        altGhosts += renderhex(myUV, lensPosition*0.1, ghostScale * 1.6, vec3(1,1,1));\n        altGhosts += renderhex(myUV, lensPosition*1.8, ghostScale * 2.0, vec3(0,0.5,0.75));\n        altGhosts += renderhex(myUV, lensPosition*1.25, ghostScale * 0.8, vec3(1,1,0.5));\n        altGhosts += renderhex(myUV, -lensPosition*1.25, ghostScale * 5.0, vec3(0.5,0.5,0.25));\n        \n        //Circular ghosts\n        altGhosts += fpow(1.0 - abs(distance(lensPosition*0.8,myUV) - 0.7),0.985)*colorGain / 2100.;\n        finalColor += altGhosts;\n      }\n      \n\n      //Starburst                     \n      if(starBurst){\n        vTexCoord = myUV + 0.5;\n        vec4 lensMod = getLensDirt(myUV);\n        float tooBright = 1.0 - (clamp(0.5, 0.0, 0.5) * 2.0); \n        float tooDark = clamp(0.5 - 0.5, 0.0, 0.5) * 2.0;\n        lensMod += mix(lensMod, pow(lensMod * 2.0, vec4(2.0)) * 0.5, tooBright);\n        float lensStarRotationAngle = ((myUV.x + myUV.y)) * (1.0 / 6.0);\n        vec2 lensStarTexCoord = (mat2(cos(lensStarRotationAngle), -sin(lensStarRotationAngle), sin(lensStarRotationAngle), cos(lensStarRotationAngle)) * vTexCoord);\n        lensMod += getLensStar(lensStarTexCoord) * 2.;\n        \n        finalColor += clamp((lensMod.rgb * getStartBurst().rgb ), 0.01, 1.0);\n      }\n\n      //Final composed output\n      if(enabled){\n        outputColor = vec4(mix(finalColor, vec3(.0), opacity) + inputColor.rgb, inputColor.a);\n      } else {\n        outputColor = vec4(inputColor);\n      }\n    }\n  `,\n}\n\ntype LensFlareEffectOptions = {\n  /** The blend function of this effect */\n  blendFunction: BlendFunction\n  /** Boolean to enable/disable the effect */\n  enabled: boolean\n  /** The glare size */\n  glareSize: number\n  /** The position of the lens flare in 3d space */\n  lensPosition: THREE.Vector3\n  /** Effect resolution */\n  screenRes: THREE.Vector2\n  /** The number of points for the star */\n  starPoints: number\n  /** The flare side */\n  flareSize: number\n  /** The flare animation speed */\n  flareSpeed: number\n  /** Changes the appearance to anamorphic */\n  flareShape: number\n  /** Animated flare */\n  animated: boolean\n  /** Set the appearance to full anamorphic */\n  anamorphic: boolean\n  /** Set the color gain for the lens flare. Must be a THREE.Color in RBG format */\n  colorGain: THREE.Color\n  /** Texture to be used as color dirt for starburst effect */\n  lensDirtTexture: THREE.Texture | null\n  /** The halo scale */\n  haloScale: number\n  /** Option to enable/disable secondary ghosts */\n  secondaryGhosts: boolean\n  /** Option to enable/disable aditional streaks */\n  aditionalStreaks: boolean\n  /** Option to enable/disable secondary ghosts */\n  ghostScale: number\n  /** TODO The opacity for this effect */\n  opacity: number\n  /** Boolean to enable/disable the start burst effect. Can be disabled to improve performance */\n  starBurst: boolean\n}\n\nexport class LensFlareEffect extends Effect {\n  constructor({\n    blendFunction,\n    enabled,\n    glareSize,\n    lensPosition,\n    screenRes,\n    starPoints,\n    flareSize,\n    flareSpeed,\n    flareShape,\n    animated,\n    anamorphic,\n    colorGain,\n    lensDirtTexture,\n    haloScale,\n    secondaryGhosts,\n    aditionalStreaks,\n    ghostScale,\n    opacity,\n    starBurst,\n  }: LensFlareEffectOptions) {\n    super('LensFlareEffect', LensFlareShader.fragmentShader, {\n      blendFunction,\n      uniforms: new Map<string, THREE.Uniform>([\n        ['enabled', new THREE.Uniform(enabled)],\n        ['glareSize', new THREE.Uniform(glareSize)],\n        ['lensPosition', new THREE.Uniform(lensPosition)],\n        ['time', new THREE.Uniform(0)],\n        ['screenRes', new THREE.Uniform(screenRes)],\n        ['starPoints', new THREE.Uniform(starPoints)],\n        ['flareSize', new THREE.Uniform(flareSize)],\n        ['flareSpeed', new THREE.Uniform(flareSpeed)],\n        ['flareShape', new THREE.Uniform(flareShape)],\n        ['animated', new THREE.Uniform(animated)],\n        ['anamorphic', new THREE.Uniform(anamorphic)],\n        ['colorGain', new THREE.Uniform(colorGain)],\n        ['lensDirtTexture', new THREE.Uniform(lensDirtTexture)],\n        ['haloScale', new THREE.Uniform(haloScale)],\n        ['secondaryGhosts', new THREE.Uniform(secondaryGhosts)],\n        ['aditionalStreaks', new THREE.Uniform(aditionalStreaks)],\n        ['ghostScale', new THREE.Uniform(ghostScale)],\n        ['starBurst', new THREE.Uniform(starBurst)],\n        ['opacity', new THREE.Uniform(opacity)],\n      ]),\n    })\n  }\n\n  update(_renderer: any, _inputBuffer: any, deltaTime: number) {\n    const time = this.uniforms.get('time')\n    if (time) {\n      time.value += deltaTime\n    }\n  }\n}\n\ntype LensFlareProps = {\n  /** Position of the effect */\n  lensPosition?: THREE.Vector3\n  /** The time that it takes to fade the occlusion */\n  smoothTime?: number\n} & Partial<LensFlareEffectOptions>\n\nconst LensFlareWrapped = /* @__PURE__ */ wrapEffect(LensFlareEffect)\n\nexport const LensFlare = ({\n  smoothTime = 0.07,\n  //\n  blendFunction = BlendFunction.NORMAL,\n  enabled = true,\n  glareSize = 0.2,\n  lensPosition = new THREE.Vector3(-25, 6, -60),\n  screenRes = new THREE.Vector2(0, 0),\n  starPoints = 6,\n  flareSize = 0.01,\n  flareSpeed = 0.01,\n  flareShape = 0.01,\n  animated = true,\n  anamorphic = false,\n  colorGain = new THREE.Color(20, 20, 20),\n  lensDirtTexture = null,\n  haloScale = 0.5,\n  secondaryGhosts = true,\n  aditionalStreaks = true,\n  ghostScale = 0.0,\n  opacity = 1.0,\n  starBurst = false,\n}: LensFlareProps) => {\n  const viewport = useThree(({ viewport }) => viewport)\n  const raycaster = useThree(({ raycaster }) => raycaster)\n  const { scene, camera } = useContext(EffectComposerContext)\n  const [raycasterPos] = useState(() => new THREE.Vector2())\n  const [projectedPosition] = useState(() => new THREE.Vector3())\n\n  const ref = useRef<LensFlareEffect>(null)\n\n  useFrame((_, delta) => {\n    if (!ref?.current) return\n    const uLensPosition = ref.current.uniforms.get('lensPosition')\n    const uOpacity = ref.current.uniforms.get('opacity')\n    if (!uLensPosition || !uOpacity) return\n\n    let target = 1\n\n    projectedPosition.copy(lensPosition).project(camera)\n    if (projectedPosition.z > 1) return\n\n    uLensPosition.value.x = projectedPosition.x\n    uLensPosition.value.y = projectedPosition.y\n    raycasterPos.x = projectedPosition.x\n    raycasterPos.y = projectedPosition.y\n    raycaster.setFromCamera(raycasterPos, camera)\n\n    const intersects = raycaster.intersectObjects(scene.children, true)\n    const { object } = intersects[0] || {}\n    if (object) {\n      if (object.userData?.lensflare === 'no-occlusion') {\n        target = 0\n      } else if (object instanceof THREE.Mesh) {\n        if (object.material.uniforms?._transmission?.value > 0.2) {\n          //Check for MeshTransmissionMaterial\n          target = 0.2\n        } else if (object.material._transmission && object.material._transmission > 0.2) {\n          //Check for MeshPhysicalMaterial with transmission setting\n          target = 0.2\n        } else if (object.material.transparent) {\n          // Check for OtherMaterials with transparent parameter\n          target = object.material.opacity\n        }\n      }\n    }\n\n    easing.damp(uOpacity, 'value', target, smoothTime, delta)\n  })\n\n  useEffect(() => {\n    if (!ref?.current) return\n\n    const screenRes = ref.current.uniforms.get('screenRes')\n    if (screenRes) {\n      screenRes.value.x = viewport.width\n      screenRes.value.y = viewport.height\n    }\n  }, [viewport])\n\n  return (\n    <LensFlareWrapped\n      // @ts-expect-error fixed with React 19\n      ref={ref}\n      blendFunction={blendFunction}\n      enabled={enabled}\n      glareSize={glareSize}\n      lensPosition={lensPosition}\n      screenRes={screenRes}\n      starPoints={starPoints}\n      flareSize={flareSize}\n      flareSpeed={flareSpeed}\n      flareShape={flareShape}\n      animated={animated}\n      anamorphic={anamorphic}\n      colorGain={colorGain}\n      lensDirtTexture={lensDirtTexture}\n      haloScale={haloScale}\n      secondaryGhosts={secondaryGhosts}\n      aditionalStreaks={aditionalStreaks}\n      ghostScale={ghostScale}\n      opacity={opacity}\n      starBurst={starBurst}\n    />\n  )\n}\n"],"names":["viewport","raycaster","screenRes"],"mappings":";;;;;;;;AAYA,MAAM,kBAAkB;AAAA,EACtB;AAAA;AAAA,IAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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"}